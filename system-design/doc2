References
https://github.com/donnemartin/system-design-primer
https://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview/

1) Zookeeper :- can help services find each other by keeping track of registered names, addresses, ports, etc.

2) DB Scaling Technique - Federation :- Federation (or functional partitioning) splits up databases by function. 
  For example, instead of a single, monolithic database, you could have three databases: forums, users, and products.
  Adv :- Index size reduces, Each can have its own cache, less traffic to each db as compared to onw whole, write requests can be in parallel and no need to serialize.
  Disadv :- Joining tables across db using a server link.

3) DB Scaling Technique - Denormalization :- Redundant copies of the data are written in multiple tables to avoid expensive joins.
  attemps to improve read performance at the expense of some write performance
  
4) SQL Tuning
  Columns that you are querying (SELECT, GROUP BY, ORDER BY, JOIN) could be faster with indices.
  Indices are usually represented as self-balancing B-tree that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time.
  When loading large amounts of data, it might be faster to disable indices, load the data, then rebuild the indices.
  Denormalize where performance demands it and avoid joins.
  Break up a table by putting hot spots in a separate table to help keep it in memory.

5) NoSQL
  Data is denormalized, and joins are generally done in the application code. 
  Most NoSQL stores lack true ACID transactions and favor eventual consistency.
  Document Store :- key-value store with documents (xml, json, binary) stored as values.
    Document stores provide APIs or a query language to query based on the internal structure of the document itself.
  WideColumn :-  nested map ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>>
    A wide column store's basic unit of data is a column (name/value pair). A column can be grouped in column families (analogous to a SQL table). Super column families further group column families. You can access each column independently with a row key, and columns with the same row key form a row. Each value contains a timestamp for versioning and for conflict resolution.
    Google introduced Bigtable as the first wide column store, which influenced the open-source HBase often-used in the Hadoop ecosystem, and Cassandra from Facebook. 
    They are often used for very large data sets.
  Graph :- each node is a record and each arc is a relationship between two nodes.  
  
6) Cache
  Your database usually includes some level of caching in a default configuration, optimized for a generic use case. Tweaking these settings for specific usage patterns can further boost performance.
  In cache, you can store objects by serializing them.
  Cache invalidation - write through, write back, write ahead, TTL for cache objects (can be used in conjunction with others).
  Write through - The application uses cache as the main source of data and not db. App req to add/update entry in cache -> cache synchronously updates db -> cache updates itself -> cache returns. Slow in case of cache miss.
  Write back - App uses cache for data and db is updated asynchronously. App req to add/update entry in cache -> cache sends update message to queue from where it is consumed asyc by the event processor -> cache updates itself -> cache returns. Cache misses are faster due to async.
  Disadv - More complex to implement, what if data lost before writing to db.
  
7) UDP 
  This is useful with DHCP because the client has not yet received an IP address, thus preventing a way for TCP to stream without the IP address.
  Use when - You need the lowest latency, Late data is worse than loss of data.

8) RPC
  In an RPC, a client causes a procedure to execute on a different address space, usually a remote server. 
  The procedure is coded as if it were a local procedure call, abstracting away the details of how to communicate with the server from the client program. 
  RPC is a request-response protocol.
  Client program - Calls the client stub procedure. The parameters are pushed onto the stack like a local procedure call.
  Client stub procedure - Marshals (packs) procedure id and arguments into a request message.
  Client communication module - OS sends the message from the client to the server.
  Server communication module - OS passes the incoming packets to the server stub procedure.
  Server stub procedure - Unmarshalls the results, calls the server procedure matching the procedure id and passes the given arguments.
  The server response repeats the steps above in reverse order.
  
9) RPC v/s REST
  - RPC has only GET and POST. REST has GET, POST, PUT, DELETE etc.
  - eg signup -> RPC : post /person, REST : post /person
       resign -> RPC : post /resign { id:'abc'}, REST : delete /person/abc
       update item -> post/modifyitem { id:'abc', value:'1234'}, put /item/abc { value:'1234'}
       get profile -> get /person?id=abc, get /person/abc
